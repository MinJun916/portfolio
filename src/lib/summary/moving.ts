import type { TroubleShootingCase } from '@/components/projects/projectTroubleShooting';

export const MOVING_SUMMARY = {
  overview: {
    title: '1. 프로젝트 개요',
    detail: [
      '이사 과정에서는 **견적 비교의 불편함**, **정보 비대칭**, **실시간 소통의 부재** 등으로 인해 사용자가 합리적인 판단을 내리기 어렵다는 문제가 존재합니다.',
      '저는 단순 기능 구현을 넘어, **실제 서비스 운영을 가정한 구조**를 설계하는 것을 목표로 프로젝트를 진행했습니다.',
    ],
  },
  contribution: {
    title: '2. 핵심 기여 및 기술적 판단',
    items: [
      {
        title: '1. 비용과 운영을 고려한 서버 설계',
        paragraphs: [
          '프로젝트 초반, **AWS EC2 기반 배포**는 규모 대비 **비용 부담**이 크다고 판단했습니다.',
          '단기 과제로 접근하지 않고 **실제 운영 환경**을 직접 설계해보고자 **Ubuntu 기반 서버**를 구축하고, **Nginx + Docker** 조합으로 배포 환경을 구성했습니다.',
          '**방화벽 설정**, **포트 분리**, **리버스 프록시**, **환경 변수 보호** 등을 직접 설계하며 **개발과 운영은 다른 문제**라는 점을 체감했습니다.',
        ],
      },
      {
        title: '2. SSR 중심 렌더링 구조 재설계',
        paragraphs: [
          'Next.js를 사용했지만 초기 구현은 **CSR 중심**이었습니다. 이로 인해 **hydration 비용 증가**와 **클라이언트 부담**이 발생했습니다.',
          '페이지의 역할에 따라 **SSR/CSR을 명확히 분리**하는 구조로 재설계했고, 가능한 많은 **렌더링 책임을 서버로 이동**시켰습니다.',
          '이를 통해 **초기 로딩 부담**을 줄이고 **클라이언트 리소스**를 경량화할 수 있었습니다.',
        ],
      },
      {
        title: '3. 데이터 집계 로직의 DB 레벨 이전',
        paragraphs: [
          '기사님의 **리뷰 수**, **평균 평점**, **확정 견적 수** 등은 여러 테이블에 분산되어 있었습니다.',
          '초기에는 **서비스 레이어**에서 집계했지만, **정렬 및 필터링 구조**에 한계가 있다고 판단했습니다.',
          '**DriverStatusView**라는 View 테이블을 생성해 **집계 로직을 DB 레벨**로 이동했고, **데이터 조회 구조**를 단순화하고 확장 가능하게 만들었습니다.',
        ],
      },
      {
        title: '4. Docker 기반 표준화 및 CI/CD 자동화',
        paragraphs: [
          '**서버 환경 차이**와 **수동 배포**로 인한 오류 가능성을 줄이기 위해 백엔드를 **Docker로 컨테이너화**했습니다.',
          '**GitHub Actions + GHCR**를 활용해 **자동 빌드 및 배포 파이프라인**을 구축했고, **디스코드 웹훅**으로 배포 상태를 공유하도록 설계했습니다.',
          '이를 통해 배포를 **개인 작업이 아닌 팀이 신뢰할 수 있는 프로세스**로 전환했습니다.',
        ],
      },
      {
        title: '5. 대량 시드 데이터 검증',
        paragraphs: [
          '설계한 구조가 **실제 환경에서도 유효한지** 검증하기 위해 **약 175만 건** 규모의 시드 데이터를 주입했습니다.',
          '초기에는 **메모리 부하**로 실패했지만, **배열 생성 및 INSERT** 과정을 **배치 처리**로 분리해 최적화했고 **로그 기반**으로 상태를 추적하며 안정적으로 완료했습니다.',
          '이를 통해 선택한 구조가 **실제 데이터 환경**에서도 견딜 수 있음을 검증했습니다.',
        ],
      },
    ],
  },
  troubleShooting: {
    title: '3. 트러블 슈팅',
    cases: [
      {
        caseTitle: '175만 건 대량 시드 데이터 처리 중 메모리 초과',
        sections: [
          {
            title: '문제 상황',
            paragraphs: [
              '프로젝트 구조가 **실제 운영 환경에서도 유효한지** 검증하기 위해 **약 175만 건** 규모의 시드 데이터를 주입하는 테스트를 진행했습니다.',
              '초기 구현에서는 모든 데이터를 **배열에 생성한 뒤 한 번에 INSERT**하는 방식을 사용했습니다.',
              '그러나 실행 도중 **서버 메모리 사용량이 급격히 증가**했고, **Node 프로세스가 중단**되는 문제가 발생했습니다.',
            ],
          },
          {
            title: '원인 분석',
            paragraphs: [
              '단순히 "데이터가 많아서"가 아니라, **데이터 생성과 INSERT가 모두 한 번에** 이루어지면서 **메모리 상에 대량 객체가 동시에 적재**되는 구조가 문제라고 판단했습니다.',
              '특히, 아래와 같은 **구조적 문제**가 있었습니다.',
            ],
            list: [
              '**배열 생성 단계**에서 대규모 객체가 메모리에 유지됨',
              '**DB INSERT가 완료될 때까지** GC가 충분히 작동하지 않음',
              '**로그 추적이 없어** 어느 단계에서 병목이 발생하는지 명확하지 않음',
            ],
          },
          {
            title: '해결 접근',
            paragraphs: [
              '저는 문제를 "코드 수정"이 아니라 **"처리 방식 재설계"**의 관점에서 접근했습니다.',
            ],
            steps: [
              {
                title: '1. 배치 처리 도입',
                list: [
                  '전체 데이터를 **작은 단위(예: 1,000건)**로 분리',
                  '**생성과 INSERT를 동일 단위로** 반복 수행',
                  '**메모리 점유 시간**을 최소화',
                ],
              },
              {
                title: '2. 로그 기반 상태 추적',
                list: [
                  '**Winston 로그**를 활용해 배치 단위 처리 상황을 기록',
                  '어느 단계에서 **병목이 발생하는지** 추적 가능하도록 개선',
                ],
              },
            ],
          },
          {
            title: '결과',
            list: [
              '**메모리 초과 문제 없이** 안정적으로 175만 건 데이터 주입 완료',
              '**전체 처리 과정의 안정성** 확보',
              '**로그 기반**으로 상태를 추적할 수 있는 구조 확립',
            ],
          },
          {
            title: '배운 점',
            paragraphs: [
              '이 경험을 통해 **"동작하는 코드"**와 **"운영 가능한 구조"**는 다르다는 점을 체감했습니다.',
              '또한 성능 문제는 알고리즘보다 **자원 사용 방식**과 **구조 설계**의 문제일 수 있다는 것을 배웠습니다.',
              '이후 기능 구현 시에도 **처리 단위**를 어떻게 나눌 것인지, **메모리와 DB 리소스**를 어떻게 사용할 것인지 먼저 고민하게 되었습니다.',
            ],
          },
        ],
      },
      {
        caseTitle: 'SSR 중심 렌더링 구조 재설계 (Hydration 비용 감소)',
        sections: [
          {
            title: '문제 상황',
            paragraphs: [
              'Next.js를 사용하고 있었지만, 초기 개발 과정에서는 **React에 익숙한 방식대로 CSR 중심**으로 화면을 구성하는 흐름이 많았습니다.',
              '그 결과 **초기 로딩 시점**에 클라이언트에서 수행해야 할 **JavaScript 실행과 hydration 범위**가 커지면서, **불필요한 렌더링 비용**이 발생한다고 판단했습니다.',
              '특히 "단순히 동작하는 화면"은 빠르게 만들 수 있었지만, **서비스가 확장될수록 초기 로딩 부담**이 커지고 **UX**에 영향을 줄 가능성이 높았습니다.',
            ],
          },
          {
            title: '원인 분석',
            paragraphs: [
              '문제의 핵심은 Next.js의 기능 부족이 아니라, **렌더링 책임이 어디에 있는지(서버 vs 클라이언트)**가 명확히 설계되지 않은 구조였습니다.',
            ],
            list: [
              '**페이지 단위로 SSR/CSR 기준**이 정리되지 않아, 습관적으로 **클라이언트 컴포넌트**가 늘어남',
              '**상호작용이 필요 없는 영역**까지 클라이언트에서 렌더링되어 **hydration 비용** 증가',
              '**"편한 구현"**을 우선하면 구조가 점점 **CSR에 쏠리는** 경향이 발생',
            ],
            paragraphsAfterList: [
              '즉, 성능 최적화는 기술 지식의 문제가 아니라 **렌더링 책임을 재배치하는 설계 문제**라고 결론냈습니다.',
            ],
          },
          {
            title: '해결 접근',
            paragraphs: [
              '저는 "CSR을 줄이자"가 아니라, **페이지의 역할을 기준**으로 렌더링 전략을 결정하는 방식으로 접근했습니다.',
            ],
            steps: [
              {
                title: '1. 페이지 성격 기준으로 SSR/CSR 분리 원칙 수립',
                list: [
                  '**기본 전략**: 가능한 많은 렌더링을 **서버에서 처리**',
                  '**예외**: 입력/상태/이벤트 등 **상호작용이 필요한 최소 영역**만 클라이언트로 분리',
                ],
              },
              {
                title: '2. 서버 컴포넌트 중심으로 구조 재설계',
                list: [
                  '대부분의 페이지를 **서버 컴포넌트 기반**으로 구성해 **SSR 흐름**을 강화',
                  '**클라이언트 컴포넌트**는 "UI 상호작용이 필요한 영역"에 한정',
                  '**클라이언트가 담당해야 할 렌더링 범위**를 의도적으로 축소',
                ],
              },
              {
                title: '3. 빌드 결과를 기준으로 렌더링 전략 검증',
                list: [
                  '설계가 실제로 반영되는지 **빌드 결과**에서 정적/서버 렌더링 페이지를 구분해 점검',
                  '**페이지별 성격**에 따라 렌더링 방식이 일관되게 선택되는지 확인하며 구조를 정리',
                ],
              },
            ],
          },
          {
            title: '결과',
            list: [
              '**불필요한 hydration 범위**를 줄이며 **초기 로딩 시 클라이언트 부담**을 완화했습니다.',
              '**"모든 것을 CSR로 해결"**하던 개발 습관에서 벗어나, **페이지 성격에 맞는 SSR/CSR 분리 설계**를 통해 **UX 중심의 렌더링 구조**를 확보했습니다.',
            ],
          },
          {
            title: '배운 점',
            paragraphs: [
              '이번 경험을 통해 프론트엔드 성능 최적화는 "특정 기술을 많이 아는 것"이 아니라, **이 페이지가 어떤 역할을 하는지** 정의하고, **렌더링 책임을 어디에 둘지** 판단하는 과정임을 체감했습니다.',
              '이후 프론트엔드를 설계할 때도 **서버가 책임져야 하는 것**, **클라이언트가 책임져야 하는 것**을 먼저 구분하고, **기능 구현보다 구조적 선택**을 우선하는 기준을 갖게 되었습니다.',
            ],
          },
        ],
      },
      {
        caseTitle: '기타 트러블 슈팅',
        layout: 'zigzag',
        sections: [
          {
            title: 'Ubuntu 서버 구축 중 운영 환경 설계 이슈',
            paragraphs: [
              '**AWS 기반 배포**는 **비용 대비 효율**이 낮다고 판단했습니다.',
              '**Ubuntu 서버**를 직접 구축하며 **방화벽**, **포트 분리**, **리버스 프록시**를 설정했고, **개발과 운영이 다른 문제**임을 체감했습니다.',
              '이후 모든 기술 선택에서 **"운영 환경에서도 유효한가?"**를 기준으로 판단하게 되었습니다.',
            ],
          },
          {
            title: 'Docker 도입 전 환경 차이 문제',
            paragraphs: [
              '**팀원별 실행 환경 차이**로 예기치 않은 오류가 발생했습니다.',
              '백엔드를 **Docker로 컨테이너화**해 **실행 환경을 표준화**했고, **GitHub Actions 기반 CI/CD**를 구축해 **배포를 자동화**했습니다.',
              '이를 통해 배포를 **개인 작업이 아닌 팀이 신뢰할 수 있는 프로세스**로 전환했습니다.',
            ],
          },
          {
            title: 'OpenAPI 기반 타입 불일치 문제',
            paragraphs: [
              '프론트엔드와 백엔드가 **동시에 개발**되며 **API 스펙 변경** 시 **타입 불일치** 위험이 있었습니다.',
              '**Swagger**를 단일 기준으로 삼고 **openapi-typescript**를 도입해 **타입을 자동 생성**하도록 구조화했습니다.',
              '타입 불일치를 **개인의 주의가 아닌 시스템**으로 방지하는 방식으로 전환했습니다.',
            ],
          },
          {
            title: 'DriverStatusView 설계 전 집계 로직의 한계',
            paragraphs: [
              '**기사 통계 데이터**를 **서비스 레이어**에서 집계하던 구조는 **정렬 및 필터링**에 한계가 있었습니다.',
              '**집계 로직을 DB View 테이블로 이전**해 **조회 구조를 단순화**하고 **확장성**을 확보했습니다.',
              '이를 통해 **데이터 처리 범위**를 애플리케이션에서 데이터베이스까지 확장해 사고하게 되었습니다.',
            ],
          },
          {
            title: '위치 기반 요청 기능 구현',
            paragraphs: [
              '요구사항에는 없었지만, 기사님 입장에서 가장 중요한 정보는 **"가까운 요청"**이라고 판단했습니다.',
              '**Geocoding**과 **Haversine 알고리즘**을 활용해 **거리 기반 요청 조회** 기능을 구현했습니다.',
              '**기능 구현을 넘어** 사용자 의사결정을 돕는 **구조를 설계**하는 경험이 되었습니다.',
            ],
          },
          {
            title: '로깅 체계 부재 문제',
            paragraphs: [
              '문제 발생 시 **감에 의존**해 원인을 추측해야 하는 상황이 반복되었습니다.',
              '**Winston**을 도입해 **로그 레벨을 분리**하고 **파일 기반 로깅 체계**를 구축했습니다.',
              '기술적 판단을 **감이 아닌 근거 기반**으로 검증할 수 있는 환경을 마련했습니다.',
            ],
          },
        ],
      },
    ] satisfies TroubleShootingCase[],
  },
};
